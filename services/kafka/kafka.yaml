apiVersion: kafka.strimzi.io/v1beta2
kind: Kafka
metadata:
  name: kafka-cluster       # Name of your Kafka cluster
  namespace: kafka              # CHANGEME: Namespace where you want Kafka deployed (e.g., "kafka")
spec:
  kafka:
    # Use a Kafka version compatible with your Strimzi/AMQ Streams operator version
    version: "3.8.0"            # Example version, check compatibility
    replicas: 1                 # Number of Kafka broker pods (use 3+ for production)
    listeners:
      # Plain listener for internal cluster communication (port 9092)
      # This is what MinIO and Knative KafkaSource will typically use internally.
      - name: plain
        port: 9092
        type: internal
        tls: false
        configuration:
          useServiceDnsDomain: true  # Ensures the service DNS domain (.cluster.local) is used
      # TLS listener for internal cluster communication (port 9093) - good practice for added security
      # If you enable this and want to use it, MinIO and KafkaSource would need TLS config.
      - name: tls
        port: 9093
        type: internal
        tls: true
        configuration:
          useServiceDnsDomain: true  # Ensures the service DNS domain (.cluster.local) is used
      # External listener (e.g., via OpenShift Route) - OPTIONAL
      # - name: external
      #   port: 9094
      #   type: route # This will create an OpenShift Route for external access
      #   tls: true
    storage:
      type: ephemeral           # Ephemeral storage (data lost on pod restart).
                                # For production, use 'persistent-claim' with an appropriate storage class and size.
                                # Example for persistent:
                                # type: persistent-claim
                                # size: 100Gi
                                # deleteClaim: false # Set to true if PVCs should be deleted when Kafka CR is deleted
    config: # Configuration for a single-broker setup
      broker.id: ${STRIMZI_BROKER_ID}  # Use the Strimzi-injected broker ID
      offsets.topic.replication.factor: 1
      transaction.state.log.replication.factor: 1
      transaction.state.log.min.isr: 1
      log.message.format.version: "3.8" # Match your Kafka version
      inter.broker.protocol.version: "3.8" # Match your Kafka version
      # Add explicit FQDN listener configuration to ensure cluster.local suffix is used
      listener.name.plain.advertised.listeners: PLAINTEXT://${HOSTNAME}.kafka-cluster-kafka-brokers.kafka.svc.cluster.local:9092
      listener.name.tls.advertised.listeners: SSL://${HOSTNAME}.kafka-cluster-kafka-brokers.kafka.svc.cluster.local:9093
      # Ensure control plane also uses FQDNs consistently
      # Additional host name verification settings
      ssl.endpoint.identification.algorithm: https
      # Ensure broker<->broker communication uses consistent DNS resolution
      broker.id.generation.enable: true
    # resources: # Define resource requests and limits for Kafka brokers for production
    #   requests:
    #     memory: 2Gi
    #     cpu: "1"
    #   limits:
    #     memory: 4Gi
    #     cpu: "2"
  zookeeper:
    replicas: 1                 # Number of Zookeeper pods (use 3+ for production)
    storage:
      type: ephemeral           # Ephemeral storage for Zookeeper. Use 'persistent-claim' for production.
    # resources: # Define resource requests and limits for Zookeeper for production
    #   requests:
    #     memory: 1Gi
    #     cpu: "500m"
    #   limits:
    #     memory: 2Gi
    #     cpu: "1"
  entityOperator:
    topicOperator: {}           # Deploys an operator to manage KafkaTopic CRs within this Kafka cluster
    userOperator: {}            # Deploys an operator to manage KafkaUser CRs (for Kafka ACLs)